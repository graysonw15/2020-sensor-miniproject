# Sensor Miniproject Report
#### By: Celia Wilkins and Grayson Wiggins

#### Task 0 Results:
After setting up the repository and python websockets, our team ran the client and server files. The greeting code was:
>ECE Senior Capstone IoT simulator

#### Task 1 Results/Commentary:
In order to get our data, our team ran the __ws_client.py__ file and __ws_server.py__ in two command prompt windows, and experienced no problems with the original code. The program was left to run for twenty minutes, yielding around a thousand data points, which we then analyzed using __analyze.py__. 
#### Task 2 Results/Commentary:
Since we were less interested in the temporal trend of the data, in order to analyze it our team used histograms and probability density functions. The most expedient way was to turn the data from each room, of each sensor, into a data frame, and we then used Python's built-in median and variance functions to print the corresponding median and variance values in the command prompt window. We used the kde function, or "kernel density estimation," to estimate the probability density functions of the temperature and occupancy data, which all resembled the "bell curve" Gaussian distribution. Our team used the Numpy mean and variance functions for the time interval data, since it was the same for all the rooms, and therefore there was no need to put it in the form of a data frame. Lab1 had temperature and occupancy medians of 21.01 C and 5 respectively, with a surprisingly small temperature variance of 1.6 C. This time interval plot reflects the Erlang Distribution where k=1 because it is exponentially decaying. 


#### Task 3 Results/Commentary:
For this task, our team created a new python file called __design.py__ - this file contains code that detects temperature anomalies and records them in a .csv file called __anamolies_log.csv__. Anamolies are defined as data that deviates from what is expected. When taking a look at the temperature recordings over time, there appear to be several extreme data points. The __Report.py__ file outputs a line plot of the temperature; when looking at this ![plot](https://github.com/graysonw15/2020-sensor-miniproject/tree/main/output_plots/Raw_TPlot.png), there are readings over 2000 degrees celcius. Since these readings cannot physically occur, our team dropped these outliers from the data. More specifically, temperatures between -31.5°C (-25°F) and 65.5°C (150°F) were dropped.

Next, our team reexamined the modified temperature plot to check for more anomalies. The __Report.py__ file outputs a modified temperature plot as well as a modified temperature PDF plot. Assessing the modified temperature ![plot](https://github.com/graysonw15/2020-sensor-miniproject/tree/main/output_plots/Modified_TPlot.png), there still appear to be large fluctuations. For example, class1 has temperatures that range from 0°C and 50°C. These large spikes are possible, but not likely, since the environments we're interested in remain around STP, and most data points are between 25°C and 30°C. Thus, applying adding an unbiased filter will be useful. The modified temperature ![PDF Plot](https://github.com/graysonw15/2020-sensor-miniproject/tree/main/output_plots/Modified_PDF.png) indicates the temperature distributions in all three rooms are gaussian-shaped. By dropping data that is further than 2 standard deviations from the mean, we effectively detect more of these anomalies. 

Finally, the gaussian-filtered temperature ![plot](https://github.com/graysonw15/2020-sensor-miniproject/tree/main/output_plots/Gauss_Filter_TPlot.png) is assessed for accurate temperature fluctuations. Here, you can see that class1 has the highest room temperature at around 27°C, followed by the office with 23°C and the lab with 20°C. There are still some fluctuations, but they are more persistant than the outliers seen before. Our team believes that the persistent fluctuations from this plot are actual changes in room temperatures, not failed sensor readings. For instance, at the 22:05 time stamp, the class1 has an increase in temperature from 26°C to 29°C. This increase makes sense because factors like air conditioning or even occupancy can have these sized effects. With all the anomalies filtered, our team was able to predict accurate bounds on room temperature. The bounds are recorded as statements in the __design.py__ code:
![print](https://github.com/graysonw15/2020-sensor-miniproject/blob/main/output_plots/Command_Output.png)

#### Conclusions

This simulation was a great exercise for our team to practice Github, websockets, and Python data-analytic modules. Using Github is reflective of a real-world application because companies often have multiple workers editing the same code. Learning to work around merge conflicts is a great skill and will be useful for the Senior Design project. Sensor anomalies also reflect real-world problems because hardware does not function the way we expect it to. Working on this simulation gave our team intuition for identifying outliers that negatively impact our data. For example, dropping a few temperature data points that were not physically possible decreased our variance from 70,000°C to 9°C. One aspect of these simulation that is not reflective of real applications is the magnitude of some of these anomalies. Looking at the most common IoT temperature sensors, their range is generally -50°C to 150°C. Some of our data points recorded in the anomalies_log.csv file had values like 6000°C. It seems unlikely that a normal IoT sensor would output such a large value. Another factor that this simulation fails to account for is the scale of the hardware. In most sensor applications, more sensors are implemented to better detect and identify trends in the environment. That said, the temperature, CO2, and Occupancy sensors are the most helpful to start with.

Since both of us are fairly new to socket programming, we thought that the Python websocket library was nice because it is high-level. For example, we were able to create a websocket with one line of code. Neither of us have used C++ before so we do not have much to compare to when it comes to socket programming.

For the scopes of this project, having sensors reach out to servers when they have data would be beneficial so that anamolies are better tracked. For example if we polled servers, persistent temperature fluctuations may be mistaken for an anomaly because the polling misses the rest of the fluctuation. Both methods are useful, it just depends on what the application of the sensor data is.


